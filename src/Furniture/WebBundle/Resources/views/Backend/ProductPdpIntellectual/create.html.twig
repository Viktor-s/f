{% extends 'SyliusWebBundle:Backend:layout.html.twig' %}

{% import 'SyliusResourceBundle:Macros:buttons.html.twig' as buttons %}
{% import 'SyliusWebBundle:Backend/Macros:alerts.html.twig' as alerts %}

{% block stylesheets %}
    {{ parent() }}
    <link rel="stylesheet" href="{{ asset('bundles/web/css/joint.min.css') }}" type="text/css" media="all" />
    <style>
        #paper {
            position: relative;
            border: 1px solid gray;
            display: inline-block;
            background: transparent;
            overflow: hidden;
        }
        #paper svg {
            background: transparent;
        }
        #paper svg .link {
            z-index: 2;
        }

        #orElementForm,
        #orAnswerElementForm,
        #inputElementForm {
            display: none;
        }

        .ui-dialog #orElementForm,
        .ui-dialog #orAnswerElementForm,
        .ui-dialog #inputElementForm {
            display: block;
        }

        .html-element {
            position: absolute;
            /*background: #3498DB;*/
            /* Make sure events are propagated to the JointJS element so, e.g. dragging works.*/
            pointer-events: none;
            -webkit-user-select: none;
            border-radius: 2px;
            /*border: 1px solid #2980B9;*/
            /*box-shadow: inset 0 0 5px black, 2px 2px 1px gray;*/
            padding: 1px;
            box-sizing: border-box;
            z-index: 2;
        }
        .html-element select,
        .html-element input,
        .html-element button {
            /* Enable interacting with inputs only. */
            pointer-events: auto;
        }
        /* port styling */
        .available-magnet {
            fill: yellow;
        }

        /* element styling */
        .available-cell rect {
            stroke-dasharray: 5, 2;
        }
        .port-label {
            display: none;
        }
    </style>
{% endblock %}
{% block headjavascript %}
    {{ parent() }}
    <script src="{{ asset('bundles/web/js/lodash.min.js') }}" type="text/javascript"></script>
    <script src="{{ asset('bundles/web/js/backbone-min.js') }}" type="text/javascript"></script>
    <script src="{{ asset('bundles/web/js/joint.min.js') }}" type="text/javascript"></script>
{% endblock %}

{% block topbar %}
    <ol class="breadcrumb">
        <li><a href="{{ path('sylius_backend_product_index') }}">Products</a></li>
        <li><a href="{{ path('sylius_backend_product_show', {id: product.id}) }}">{{ product.name }}</a></li>
        <li><a href="{{ path('furniture_backend_product_pdp_intellectual_index', {productId: product.id}) }}">PDP Intellectuals</a></li>
        <li>Create</li>
    </ol>
{% endblock %}

{% block content %}
    <div class="page-header">
        <h1><i class="glyphicon glyphicon-plus"></i> Create</h1>
    </div>
    {% include 'WebBundle:Backend/ProductPdpIntellectual:form.html.twig' %}

    <div class="row">
        <div class="col-sm-12">
            <div class="row">
                <div class="col-sm-6">
                    <div class="btn-toolbar" role="toolbar">
                        <div class="btn-group" role="group">
                            <button id="addOrBtn" type="button" class="btn btn-sm">
                                OR (Question)<span class="glyphicon glyphicon-plus-sign" aria-hidden="true"></span>
                            </button>
                            <button id="addOrAnswerBtn" type="button" class="btn btn-sm">
                                OR answer <span class="glyphicon glyphicon-plus-sign" aria-hidden="true"></span>
                            </button>
                        </div>
                    </div>
                </div>
                <div class="col-sm-6">
                    <div class="btn-toolbar" role="toolbar">
                        <div class="btn-group" role="group">
                            <button id="getTree" class="btn btn-sm" type="button">Get tree</button>
                            <button id="getSchemes" class="btn btn-sm" type="button">Get schemes</button>
                        </div>
                    </div>
                </div>
            </div>
            <div class="row">
                <div class="col-lg-10 col-sm-8">
                    <div id="paper">
                    </div>
                </div>
                <div class="col-lg-2 col-sm-4">
                    <div class="btn-group-vertical" role="group" aria-label="pdp-inputs">
                {% if product %}
                    {% for input in product.pdpConfig.inputs if not input.forSchemes %}
                        {% if input.productPart %}
                            {% set btnId = 'productPart' %}
                            {% set name = 'Material' %}
                        {% elseif input.skuOption %}
                            {% set btnId = 'skuOption' %}
                            {% set name = 'SKU' %}
                        {% elseif input.option %}
                            {% set btnId = 'option' %}
                            {% set name = 'Option' %}
                        {% endif %}
                        <button id="add{{ btnId ~ input.id }}" type="button" class="btn btn-sm" data-input-type="{{ btnId }}" data-input-name="{{ input.humanName }}" data-input-id="{{ input.id }}">
                            {{ name }} {{ input.humanName }} <span class="glyphicon glyphicon-plus-sign" aria-hidden="true"></span>
                        </button>
                    {% endfor %}
                {% endif %}
                    </div>
                </div>
                <div class="col-sm-12">
                    <h3>Schemes preview:</h3>
                    <div id="schemes-preview"></div>
                </div>
            </div>
        </div>
    </div>
    <script>

    var inputs = [];
    {% if product %}

        {% for input in product.pdpConfig.inputs %}

    inputs.push({
        id:{{ input.id|json_encode(constant('JSON_UNESCAPED_UNICODE'))|raw}},
                name:{{ input.humanName|json_encode(constant('JSON_UNESCAPED_UNICODE'))|raw }},
                type:{% if input.option %}
                'option'
                {% elseif input.skuOption %}
                    'skuOption'
                {% elseif input.productPart %}
                    'productPart'
                {% elseif input.forSchemes %}
                    'scheme'
                {% endif %}
        });
        {% endfor %}
    {% endif %}
    console.log(inputs);

    var graph = new joint.dia.Graph;
    $(document).ready(function () {

        paper = new joint.dia.Paper({
            el: $('#paper'),
            width: $('#paper').parent('div').outerWidth(),
            height: 800,
            model: graph,
            gridSize: 1,
            markAvailable: true,
            defaultLink: new joint.dia.Link({
                attrs: { '.marker-target': { d: 'M 10 0 L 0 5 L 10 10 z' } }
            }),
            validateConnection: function(cellViewS, magnetS, cellViewT, magnetT, end, linkView) {
                var rootCell = graph.getFirstCell();
                var elementS = graph.getCell(cellViewS.model.id);
                var elementT = graph.getCell(cellViewT.model.id);
                var link = linkView.model;

                // Prevent linking from input ports.
                if (magnetS && magnetS.getAttribute('type') === 'input') return false;
                // Prevent linking from output ports to input ports within one element.
                if (cellViewS === cellViewT) return false;

                // Check all input ports.
                var magnetTCheck = magnetT && magnetT.getAttribute('type') === 'input';

                linkView.sendToken(V('circle', { r: 7, fill: 'green' }).node);
                var connectedTLinks = graph.getConnectedLinks(elementT, {inbound: true});

                var alreadyTConnected = connectedTLinks.length && !_.contains(connectedTLinks, link);
                // Check that elements are connected.
                // Elements already connected

                if (graph.isNeighbor(elementT, elementS) && alreadyTConnected) return false;

                // Root element connected only with AND and OR elements.
                if (elementS.get('isRoot')) {
                    return  _.contains(['pdpInput.Input', 'pdpInput.Or'], elementT.get('type'))
                            && magnetTCheck
                            && !alreadyTConnected;
                }

                // OR elements can connect only OR answers.
                if (elementS.get('type') === 'pdpInput.Or') {
                    return _.contains(['pdpInput.OrAnswer'], elementT.get('type'))
                            && magnetTCheck
                            && !alreadyTConnected;
                }

                // OR Answer elements can connect with AND, OR or PDP inputs.
                if (elementS.get('type') === 'pdpInput.OrAnswer') {
                    // Check that Or elements already has input connection.
                    if (elementT.get('type') == 'pdpInput.Or' && alreadyTConnected) {
                        return false;
                    }

                    if (elementT.get('type') == 'pdpInput.Input') {
                        if (alreadyTConnected) {
                            // Do not connect with inputs that connected with root.
                            if (graph.isNeighbor(rootCell, elementT, {outbound: true})) {
                                return false;
                            }
                        }

                        // do not connect with Inputs that haven't have common ancestor with source.
//                        var commonAncestor = graph.getCommonAncestor(elementS, elementT);
//                        if (graph.isNeighbor(commonAncestor, elementS, {inbound: true})) {
//
//                        }
                        // Do not connect with skuOptions.
                        if (elementT.get('inputType') === 'skuOption') {
                            return false;
                        }
                    }

                    return _.contains(['pdpInput.Input', 'pdpInput.Or'], elementT.get('type')) && magnetTCheck;
                }

                // Prevent linking to input ports.
                return magnetTCheck;
            },
            validateMagnet: function(cellView, magnet) {
                var element = graph.getCell(cellView.model.id);

                // Restrict magnet routs for Root element.
//                if (element.get('isRoot')) {
//                    return !graph.getConnectedLinks(element, {outbound: true}).length >= 1;
//                }
                // Note that this is the default behaviour. Just showing it here for reference.
                // Disable linking interaction for magnets marked as passive (see below `.inPorts circle`).
                return magnet.getAttribute('magnet') !== 'passive';
            },
            snapLinks: { radius: 50 }
        });

        graph.on('all', function (eventName, cell) {
//            console.log('graph', arguments);
        });

        paper.on('all', function (eventName, cell) {
//            console.log('paper', arguments);
        });

        //Creating root element
        var rootCell = new joint.shapes.devs.Atomic({
            position: { x: 250, y: 50 },
            size: { width: 100, height: 30 },
            outPorts: ['out'],
            isRoot: true,
            attrs: {
                rect: {fill: 'blue'},
                text: {text: 'Root', fill: 'white'},
                '.outPorts circle': { fill: '#E74C3C'},
            }
        });

        graph.addCells([rootCell]);

        joint.shapes.pdpInput = {};

        var pdpIntelligentProcessor = function(graph) {
            this.graph = graph;
            this.root = graph.getFirstCell();
            this.schemes = [];
            this.levels = [];
            this.messageElement = null;
        };
        pdpIntelligentProcessor.prototype = {
            // Validator
            validator: function() {
                var that = this;
                var valid = true;
                var errors = [];
                return {
                    validate: function() {
                        var _self = this;
                        // First step to check all elements are connected.
                        var cells = that.graph.getCells();

                        if (cells.length == 1) {
                            errors.push('Please add more elements.');

                            valid = false;
                        } else {
                            var elementsCheck = false;
                            _.each(cells, function(cell) {
                                if (cell.isLink() && valid) {
                                    if (typeof cell.get('source').id === 'undefined' || typeof cell.get('target').id === 'undefined') {
                                        errors.push('You have links that not connected with elements.');
                                        valid = false;
                                    }
                                } else {
                                    var connectedLinks = that.graph.getConnectedLinks(cell);
                                    if (_.isEmpty(connectedLinks) && valid) {
                                        errors.push('All elements should be connected.');

                                        valid = false;
                                    } else if (cell.get('type') === 'pdpInput.Input') {
                                        elementsCheck = true;
                                    }
                                }
                            });

                            if (!elementsCheck) {
                                errors.push('PDP inputs not founded');
                                valid = false;
                            }



                            // All other validations.
                            _.each(that.graph.getSinks(), function(element) {
                                if (element.get('type') === 'pdpInput.Or') {
                                    errors.push("Or element can't be last, please add answer.");

                                    valid = false;
                                }
                            });
                        }

                        if (!valid) {
                            this.showErrors(errors);
                        } else {
                            this.hideMessages();
                        }

                        return valid;
                    },
                    setMessagesElement: function(ele) {
                        if ($.type(ele) === 'string') {
                            ele = $(ele)
                        }

                        if (ele.length) {
                            that.messageElement = ele;
                        }
                    },
                    showErrors: function(errors) {
                        var _self = this;
                        that.messageElement.html('');
                        if ($.type(that.messageElement) !== 'null') {
                            _.each(errors, function(error) {
                                that.messageElement.append($(_self.messageTemplate(error)));
                            });
                        }
                    },
                    showError: function(error) {
                        var _self = this;
                        if ($.type(that.messageElement) !== 'null') {
                            that.messageElement.html('').append($(_self.messageTemplate(error)));
                        }
                    },
                    hideMessages: function() {
                        that.messageElement.html('');
                    },
                    messageTemplate: function(error) {
                        return '<div class="alert alert-danger">' +
                                 '<button type="button" data-dismiss="alert" class="close" aria-hidden="true">&times;</button>' +
                                 error +
                                '</div>';
                    }
                };
            },
            // Convert tree to serializable object.
            converter: function() {
                var that = this;
                return {
                    convertToObject: function() {
                        return this.convertExpression(that.root, 1)
                    },
                    convertExpression: function(cell, type) {
                        var _self = this;
                        var successors = that.graph.getNeighbors(cell, {outbound: true});
                        var predecessors = that.graph.getNeighbors(cell, {inbound: true});
                        var successorsIds = (function(array) {
                            return _.map(array, function (ele) {
                                return ele.get('id');
                            });
                        })(successors);
                        var predecessorsIds = (function(array) {
                            return _.map(array, function (ele) {
                                return ele.get('id');
                            });
                        })(predecessors);

                        var data = {
                            type: type,
                            appendText: '',
                            prependText: cell.get('prependText'),
                            child: [],
                            elements: [],
                        };

                        if (successors.length > 0) {
                            $.each(successors, function(i) {
                                if (this.get('type') === 'pdpInput.Or') {
                                    data.child.push(_self.convertExpression(this, 2));
                                } else if (this.get('type') === 'pdpInput.OrAnswer') {
                                    data.child.push(_self.convertExpression(this, 1));
                                } else if (_.contains(['pdpInput.Input'], this.get('type'))) {
                                    data.elements.push(_self.convertElementToArray(this));
                                }
                            });
                        }

                        return data;
                    },
                    convertElementToArray: function(element){
                        var predecessors = that.graph.getNeighbors(element, {inbound: true});
                        var predecessorsIds = (function(array) {
                            return _.map(array, function (ele) {
                                return ele.get('id');
                            });
                        })(predecessors);
                        return {
                            input: element.get('inputId'),
                            appendText: '',
                            prependText: element.get('inputName'),
                        }
                    }
                };
            },
            schemesCreator: function() {
                var that = this;
                return {
                    draw: function(el) {
                        var _self = this;
                        this.create();
                        if (this.schemesValidate()) {
                            var table = $('<table/>').addClass('table table-striped table-hover');
                            var tRow, tCell, numCols = 2;
                            _.each(that.schemes, function(scheme, idx){

                                var schemeName = '', elements = [];
                                _.each(scheme, function(step) {
                                    elements = _.uniq(_.toArray($.merge(elements, step.elements)));
                                });

                                _.each(elements, function(element) {
                                    schemeName += element.get('inputName') + ' | ';
                                });


//                            if(!(idx %numCols))
                                tRow = $('<tr>');
                                tCell = $('<td>').html(schemeName);
                                tRow.append(tCell);
                                tCell = $('<td>').html('-');
                                tRow.append(tCell);
//                            table.append(tRow.append(tCell));
                                table.append(tRow.append(tCell));
                            });

                            el.html($('<div>').append($('<div class="table-responsive"></div>').append(table)).html());
                        }
                    },
                    create: function(){
                        var _self = this;
                        var levels = [], schemes = [];
                        var ancestor, ancestors, successors, schemesPartition, parsed, processed, first, cloneLevels, step;
                        that.levels = [];
                        _self.getLevels();
                        // clone variable to prevent
                        cloneLevels = that.levels.slice(0);
                        cloneLevels.shift();

                        _.each(cloneLevels, function(vars, level){
                            step = _self.parseCollection(vars);

                            if (level === 0) {
                                schemes.push([{
                                    children: step.or,
                                    elements: step.elements
                                }]);
                            } else {
                                if (!_.isEmpty(step.answer)) {
                                    // For answers
                                    processed= [];
                                    while (!_.isEmpty(step.answer)) {
                                        first = step.answer.shift();
                                        ancestor = that.graph.getNeighbors(first, {inbound:true}).shift();
                                        var grandancestor = that.graph.getNeighbors(ancestor, {inbound:true}).shift();
                                        successors = that.graph.getNeighbors(grandancestor, {outbound:true});
                                        parsed = _self.parseCollection(successors);
                                        schemesPartition = _self.getSchemesPartitions(schemes, parsed.or, level);
                                        schemes = schemesPartition[1];

                                        _.each(parsed.or, function(element) {
                                            var children = that.graph.getNeighbors(element, {outbound: true});
                                            processed = $.merge(processed, children);
                                        });

                                        step.answer = _.reject(step.answer, function(element) {
                                            return _.contains(processed, element);
                                        });

                                        // Scheme multiple with answers.
                                        var combinations = _self.getCombinations(parsed.or);

                                        _.each(schemesPartition[0], function(scheme) {
                                            _.each(combinations, function(combination) {
                                                var newScheme = scheme.slice(0);
                                                newScheme[level] = {
                                                    children: _.isArray(combination) ? combination : [combination],
                                                    elements: []
                                                };
                                                schemes.push(newScheme);
                                            });
                                        });
                                    }
                                } else if (!_.isEmpty(step.elements) || !_.isEmpty(step.or)) {
                                    // For questions.
                                    processed = [];
                                    while (!_.isEmpty(step.or)) {
                                        first = step.or.shift();
                                        ancestor = that.graph.getNeighbors(first, {inbound:true}).shift();
                                        successors = that.graph.getNeighbors(ancestor, {outbound:true});
                                        parsed = _self.parseCollection(successors);
                                        schemesPartition = _self.getSchemesPartitions(schemes, [ancestor], level);
                                        schemes = schemesPartition[1];

                                        processed = $.merge(processed, parsed.or)

                                        step.or = _.reject(step.or, function(element) {
                                            return _.contains(processed, element);
                                        });

                                        _.each(schemesPartition[0], function(scheme) {
                                            if (typeof scheme[level] === 'undefined' && !_.isEmpty(parsed.or)) {
                                                scheme[level] = {
                                                    children: [],
                                                    elements: []
                                                };
                                            }

                                            scheme[level].children = _.toArray($.merge(scheme[level].children, parsed.or));
                                            schemes.push(scheme);
                                        });
                                    }
                                    // For elements.
                                    processed = [];
                                    while (!_.isEmpty(step.elements)) {
                                        first = step.elements.shift();
                                        ancestors = that.graph.getNeighbors(first, {inbound:true});
                                        _.each(ancestors, function(ancestor){
                                            // Check that ancestor is on the same step.
                                            // Otherwise it's been already processed.
                                            if (_.contains(that.levels[level], ancestor)) {
                                                successors = that.graph.getNeighbors(ancestor, {outbound:true});
                                                parsed = _self.parseCollection(successors);
                                                schemesPartition = _self.getSchemesPartitions(schemes, [ancestor], level);
                                                schemes = schemesPartition[1];

                                                processed = _.uniq($.merge(processed, parsed.elements));
                                                step.elements = _.reject(step.elements, function(element) {
                                                    return _.contains(processed, element);
                                                });

                                                _.each(schemesPartition[0], function(scheme) {
                                                    if (typeof scheme[level] === 'undefined' && !_.isEmpty(parsed.elements)) {
                                                        scheme[level] = {
                                                            children: [],
                                                            elements: []
                                                        };
                                                    }
                                                    scheme[level].elements = _.uniq(_.toArray($.merge(scheme[level].elements, parsed.elements)));
                                                    schemes.push(scheme);
                                                });
                                            }
                                        });
                                    }
                                }
                            }
                        });
                        that.schemes = schemes;
                        console.log('that', that);
                    },
                    schemesValidate: function() {
                        if (that.schemes.length == 1) {
                            that.validator().showError('Please create at least two schemes by adding more answers or questions.');
                            return false;
                        } else {
                            var hashes = [];
                            _.each(that.schemes, function(scheme, idx) {
                                var elements = [];
                                _.each(scheme, function(step) {
                                    _.each(step.elements, function (ele) {
                                        elements.push(ele.get('id'));
                                    });
                                });
                                elements.sort();
                                var hash = elements.join('');

                                if (_.contains(hashes, hash)) {
                                    that.validator().showError('Please create different schemes variants.');
                                    return false;
                                }

                                hashes.push(hash);
                            });
                        }

                        return true;
                    },
                    getLevels: function(distance) {
                        distance = typeof distance === 'undefined' ? 0 : distance;
                        if (distance == 0) {
                            that.levels[distance] = [that.root];
                        }

                        var successors = [];
                        _.each(that.levels[distance], function(element){
                            successors = _.toArray($.merge(successors, that.graph.getNeighbors(element, {outbound:true})));
                        });

                        if (successors.length > 0) {
                            that.levels[++distance] = successors;
                            this.getLevels(distance);
                        }
                    },
                    parseCollection: function(level) {
                        return {
                            or: _.filter(level, function(ele) {
                                return ele.get('type') === 'pdpInput.Or';
                            }),
                            answer: _.filter(level, function(ele) {
                                return ele.get('type') === 'pdpInput.OrAnswer';
                            }),
                            elements: _.filter(level, function(ele) {
                                return ele.get('type') === 'pdpInput.Input';
                            })
                        };
                    },
                    getSchemesPartitions: function(schemes, elements, level, type) {
                        type = type || 'all';
                        return _.partition(schemes, function(scheme) {
                            if (_.isEmpty(elements)) return false;
                            var predicate = function(ele) {
                                return typeof scheme[level-1] !== 'undefined' && _.contains(scheme[level-1].children, ele);
                            };

                            return type === 'all' ? _.all(elements, predicate): _.any(elements, predicate);
                        });
                    },
                    getCombinations: function(elements) {
                        var first = elements.shift();
                        var combinations = that.graph.getNeighbors(first, {outbound: true});

                        while (!_.isEmpty(elements)) {
                            first = elements.shift();
                            var newCombination = [];
                            for (var i in combinations) {
                                var answers = that.graph.getNeighbors(first, {outbound: true});
                                for (var j in answers) {
                                    if (_.isArray(combinations[i])) {
                                        var temp = combinations[i].slice(0);
                                        temp.push(answers[j]);
                                        newCombination.push(temp);
                                    } else {
                                        newCombination.push([combinations[i], answers[j]]);
                                    }
                                }
                            }
                            combinations = newCombination;
                        }

                        return combinations;
                    }
                }
            }
        };

        pdpProcessor = new pdpIntelligentProcessor(graph);
        pdpProcessor.validator().setMessagesElement('#flashes');
        var rootTreeElement = $('#pdp_intellectual_root_tree');
        var graphJsonElement = $('#pdp_intellectual_root_graphJson');
        var schemesPreviewElement = $('#schemes-preview');
        $('#getTree').on('click', function() {
            if (pdpProcessor.validator().validate() && pdpProcessor.schemesCreator().schemesValidate()) {
                rootTreeElement.val(JSON.stringify(pdpProcessor.converter().convertToObject()));
                graphJsonElement.val(JSON.stringify(graph.toJSON()));
            }
        });

        $('#getSchemes').on('click', function() {
            if (pdpProcessor.validator().validate()) {
                pdpProcessor.schemesCreator().draw(schemesPreviewElement);
            }
        });
    });
</script>
{% include 'SyliusWebBundle:Backend/ProductPdpIntellectual/EditorElements:Element.html.twig' %}
{% include 'SyliusWebBundle:Backend/ProductPdpIntellectual/EditorElements:InputElement.html.twig' %}
{% include 'SyliusWebBundle:Backend/ProductPdpIntellectual/EditorElements:OrElement.html.twig' %}
{% include 'SyliusWebBundle:Backend/ProductPdpIntellectual/EditorElements:OrAnswerElement.html.twig' %}
{% endblock %}